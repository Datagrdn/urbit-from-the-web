---
navhome: /docs/
next: false
title: Part 1
---

# Urbit from the Web

## Part 1

### Overview

Here in Part 1, we're going to cover the basics of how to communicate with an Urbit ship's backend from a trivial vanilla frontend using our `urb.js` HTTP API and `:talk` as a simple message bus. We'll be able to send direct messages to our ship and other ships, create new personal "stations" where we can aggregate messages, and load a station's messages on the page.

If you haven't already, follow the instructions in our documentation to [install Urbit](https://urbit.org/docs/using/install) and [setup your first ship](https://urbit.org/docs/using/setup). You'll be able to boot a free _comet_, or disposable Urbit identity, to serve as the ship for this tutorial.

Let's get started!

### Let's start up our ship!

Fire up your ship as per our [basic operation](https://urbit.org/docs/using/admin/) doc.

```
$ urbit mycomet
```

If your ship is running, you'll be in a `:dojo` prompt. Something like this:

```
~
urbit 0.4.4
urbit: home is mycomet
...
http: live (insecure, public) on 8080
http: live ("secure", public) on 8443
http: live (insecure, loopback) on 12321
ames: czar zod.urbit.org: ip .104.197.214.171
~darlen_dolmyn:dojo>
```

where `~darlen_dolmyn` is your comet name, abbreviated.

For those still new to Urbit, the `:dojo` is just Urbit's version of a command line.

You can see your full comet name with the `our` dojo command.

```
~darlen_dolmyn:dojo> our
~darlen-natleb-modwer-falrud--bisrev-haltyd-ralwex-dolmyn
```

You'll need this long comet name in a second.

> From now on, we'll abbreviate the `~darlen_dolmyn:dojo` prompt to just `>`:

> ```
> > our
> ~darlen-natleb-modwer-falrud--bisrev-haltyd-ralwex-dolmyn
> ```

### 1.0 - Let's serve a file to the web.

We'll assume your ship's `%clay` filesystem is mounted to your local machine as per the setup doc linked in the overview above.

An Urbit ship boots with a default Arvo `home` *desk*, or version-controlled directory:

```
$ ls mycomet/home
app  arvo  gen  lib  mar  ren  sec  sur  web  web.md
```

Your home desk's `web` directory is the equivalent of a public_html directory. Your ship looks in this directory to serve content to the world.

More details [here](https//urbit.org/docs/using/web/).

For this tutorial, we've included all the necessary frontend code for you to run in a Git repo for you to clone.

Go ahead and clone the following repo somewhere:

```
$ git clone https://github.com/keatondunsford/urbit-from-the-web.git
```

Then, copy all the files inside to your web directory:

```
$ cp -r urbit-from-the-web mycomet/home/web
```

As we progress, you can simply `git checkout` to the appropriate branch for the section, and everything should just work.

Our first example for this section is in the `1.0` branch, so let's go ahead and `cd` into our web directory and checkout to the `1.0` branch to serve our first example to the web. We'll use the `-f` flag to force the changes between branches:

```
$ cd mycomet/home/web
$ git checkout -f 1.0
```

If this worked, you should see in your `:dojo` that your ship registered that a new file was imported, a `tutorial.html` file:

```
+ /~darlen-natleb-modwer-falrud--bisrev-haltyd-ralwex-dolmyn/home/2/web/tutorial/html
>
```

This is just an HTML Hello World:

```
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Urbit from the Web</title>
  </head>
  <body>

    <div>
      <h1>Hello, Mars!</h1>
    </div>

  </body>
</html>
```

This file is now already being served to the web.

Your Urbit web directory gets served to `localhost` port `8443`. Let's load that up:

```
http://localhost:8443/tutorial.html
```

Sure enough:

!['Hello, Mars!'](https://cloud.githubusercontent.com/assets/13459143/23774338/0fb64660-04d8-11e7-987c-3d25652c9482.png)

Every running ship also maps to urbit.org's DNS at `ship.urbit.org`. So if you go grab your full comet name from the `:dojo` `our` command again, you can see your this page at something like `https://darlen-natleb-modwer-falrud--bisrev-haltyd-ralwex-dolmyn.urbit.org/tutorial.html` in your browser. Things should be working just the same.

> Note that if you had a first Urbit ship running when you started up your current comet, your web directory will be served to `https://localhost:8444`; two other ships running, `https://localhost:8445`, etc.

### 1.1 - Let's run some JavaScript.

Checkout to the `1.1` branch for this section:

```
$ git checkout -f 1.1
```

If you look back in your `:dojo`, you should see that your ship recognized a change to the file:

```
: /~darlen-natleb-modwer-falrud--bisrev-haltyd-ralwex-dolmyn/home/3/web/tutorial/html
>
```

The version-control number of your home directory should be incremented as a result of the change.

All we did was add a button and this `<script>` tag to your tutorial.html body:

```
<body>

    <div>
      <h1>Hello, Mars!</h1>
      <button onclick="someJavaScript();">A button test!</button>
    </div>

    <script>
      console.log('We\'re serving some JavaScript through Urbit to the browser!');

      function someJavaScript () {
        console.log('Now we\'re calling some other JavaScript.')
      }
    </script>

  </body>
```

A quick page reload and a look at your browser dev tool Console shows our vanilla JavaScript works:

![We're serving some JavaScript through Urbit to the browser.](https://cloud.githubusercontent.com/assets/13459143/23775012/5fc32fee-04db-11e7-9cad-116cca2528b8.gif)

Keeping our main development workflow in a Git repo and just `cp`ing our changes into our ships helps us keep our changes in sync and keep track of what code is running where, especially when we're switching between various [fake ships](https://urbit.org/fora/posts/~2017.1.5..21.31.04..20f3~/), comets and planets for testing.

### 1.2 - Time to talk to Urbit.

Let's start with a hard-coded way to say hi to our ship.

Checkout to the `1.2` branch and copy in the .html file once more:

```
$ git checkout -f 1.2
$ cp tutorial.html ~/mycomet/home/web
```

Save, and reload the page.

With your browser Console open and your `:dojo` in sight, just click the button!

> hi appears on page gif

Let's go over what just happened.

Somehow from clicking that button, you were able to talk to your ship.

We did this using the simple HTTP API in our small `urb.js` library, which is included in all booted ships' web directories by default. We sourced urb.js in our .html file via a `<script src>` tag in our `<head>`.

Here's the code:

```
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>An Urbit social app tutorial</title>

    <script src="/~/at/=home=/web/lib/js/urb.js"></script>

  </head>
  <body>

    <br />

    <div>
      <button onclick="sayHi();"><h1>Say hi to your ship!</h1></button>
    </div>

    <br />

    <div id="loadHi">
    </div>

    <script>
      function sayHi () {
        window.urb.send('hi. :)', {
          appl: 'hood',
          mark: 'helm-hi'
        }, function (err, res) {
          if (err || !res.data) {
            console.log(path, 'err!');
            console.log(err);
            return;
          }
          console.log('We just said hi to our ship!');
          console.log(res.data);
        });

        var hi = '';
        hi += '<div class="hi">';
        hi += '<h2><code>< ~' + window.urb.ship + ': hi. :)</code></h2>'
        hi += '</div>';
        return document.getElementById('loadHi').innerHTML = hi;

      };

    </script>

  </body>
</html>
```

`/=home=/` in that `<script src>` tag just means, "your most current home directory", since everything is version-controlled through %clay.

By appending the `/~/at/` before the file path in that tag, we told our ship to inject authentication and user data to the top of our urb.js file under the `window.urb` object. You can inspect the top of the source file in dev tools:

> screenshot of highlighted injected data

Let's pretty-print that:

```
var _urb = {
  "oryx": "bardys-ridmes-salser-napreg--watwer-ribmyn-midsul-digber",
  "user": "darlen-natleb-modwer-falrud--bisrev-haltyd-ralwex-dolmyn",
  "sein": "zod",
  "ixor": "morret-taspeg-ritlug-fortug",
  "ship": "darlen-natleb-modwer-falrud--bisrev-haltyd-ralwex-dolmyn",
  "auth": [
    "darlen-natleb-modwer-falrud--bisrev-haltyd-ralwex-dolmyn"
  ]
};
```

Urbit code on both the backend and frontend has trended towards four-letter "lapidary" style. Thankfully, much of the naming conventions on the frontend side are getting overhauled in the direction of `understandableCamelCase` in our upcoming [`%eyre` and `:tree` improvements](urbit.org/fora/posts/~2017.1.5..01.33.40..2a0e~/). But for now, we're stuck with the question, "What the hell is an `oryx`?" Luckily, these aren't too hard to explain.

An `oryx` is just a [CSRF token](https://en.wikipedia.org/wiki/Cross-site_request_forgery) for authentication. `ixor` is a hash of this CSRF token, also for authentication. `user`, `ship` and `auth` are all additionally there for authentication; if one of the three doesn't match, your ship will know something isn't right. And lastly, `sein` is the parent of the current ship; all comets have galaxy parents, and in this case, our parent is `~zod`. This is needed so your ship knows where to get its packets, or _cards_ from.

If you look in the actual JavaScript of your HTML body's `<script>`, we wrote a `'hi'` `<div>` to display the value of `window.urb.ship`, which, as per the injected data above, in this case is your comet ship name. We added some extra text in the div to mimic the 'hi' message you got in your `:dojo`. Then we just set our `onClick` button event to call our `sayHi` function which, upon clicking the button, swapped the empty `loadHi` `<div>` with the above 'hi' div that displays your hi message.

urb.js has several wrapper functions over different [XMLHttpRequests](https://en.wikipedia.org/wiki/XMLHttpRequest) that can send different requests to your ship's web server, `%eyre`. For this simple example, we called the `urb.send` function, which takes as arguments a data value, an object of parameters further specifying the message being sent, and a callback function to execute upon a successful or failed request. The function then takes the data value and message parameters and inputs them as arguments to `JSON.stringify`, the product of which is sent as a JSON payload to your ship's backend. You ship was then able to parse this JSON and send the right contents to the right Hoon program for execution.

Let's open up our Network tool in our browser dev tools to look at what JSON payload `urb.send` delivered:

> screenshot of payload

Pretty-printed:

```
{
  "oryx": "modtuc-diffus-ropdef-novluc--satlev-tomrut-lodres-digweg",
  "xyro": "hi. :)",
  "ship": "darlen-natleb-modwer-falrud--bisrev-haltyd-ralwex-dolmyn",
  "appl": "hood",
  "mark": "helm-hi",
  "wire": "/"
}
```

We're already familiar with what our `oryx` is: an authenticated CSRF token. Our data value, named `xyro`, was just the string 'hi. :)'. The default `ship` value is the same one in the `window.urb` object described above. The `params` we specified we placed in an object that contained two name-value pairs: our `appl`, for 'application', was `hood`, your ship's system daemon, and our `mark`, or message type, was a `helm-hi`, which just told `hood` to run our simple _helm-hi_ Hoon program to take the data value sent and print it to the screen, like a traditional 'Hello, world!'. And the `wire` value we didn't use this time and thus just defaulted to its fallback value, but in other kinds of requests, as we'll see in a later section, adding a wire path can allow us to do some pretty cool things.

Lastly, upon the successful request, our callback function simply console.logged the request response; our ship sent us an `{ok:true}`, meaning "everything is all good!". And it console.logged a string we hard-coded, telling us we just said hi to our ship.

Another example will help make more sense of this. Let's try sending ourselves a `:talk` message.

### 1.3 - Let's send some messages using `:talk`

`:talk` is our most full-fledged app on Urbit right now, with a backend standing at about 2400 lines of Hoon code. Our primary use case for `:talk` right now is a sort of distributed, encrypted Slack that can be used from the CLI and the browser.

But really, the `:talk` protocol is a general-purpose piece of infrastructure for messaging and notifications that `:talk`-the-app just happens to use. Meaning, we can actually use the `:talk` protocol as a basic message bus to power any kind of app.

Before we checkout to the next branch, let's send ourselves a quick message from the `:talk` CLI, and then take a minute to officially `Log In` to our ship through `:Tree`, Urbit's main general web UI. This will give us full authentication privileges so our messages later in this section can be sent smoothly. And we can also take a peek at `:talk` the web app to better understand the `:talk` protocol it's built on top of.

First, sending from the CLI: right now, you should still be in your `:dojo` prompt in your ship's running terminal window. We've built in a keyboard command to quickly switch between `:dojo` and `:talk` prompts: just `Ctrl-x`.

With your ship's terminal window focused, press `Ctrl-x` on your keyboard, which should bring you into the `:talk` command-line interface:

```
~darlen_dolmyn:talk[]
```

The `[]` indicates we have ourselves as our message audience. Try sending yourself a message!

> gif of sending self message from the CLI.

Pretty straightforward, right?

Now let's do the same thing, but this time from your `:talk` web UI. To do this, as said above, we first need to `Log In` to fully authenticate your ship through Tree.

In your browser again, head to your home page being served at `https://localhost:8443`:

> screenshot of home page

and `Log In` at the top right.

We store your web password in your ship itself. You can retrieve it with the `+code` `:dojo` command.

Press `Ctrl-x` again to switch back into the `:dojo`, and enter the command:

```
> +code
```

which will give you a four-word password, something like:

```
rapfex-borsef-hacnes-tognet
>
```

Paste that into the password field of the Log In page:

> screenshot of password field filled

and hit Enter, which should bring you back to your home page logged in with the ability to access `:talk`.

> screenshot of home page with now-showing panel.

Cool. So let's check out `:talk` the web app.

Click the ``:talk`` link in the top left, or just enter the URL yourself : `localhost:8443/talk`. You'll load up the `:talk` web UI:

> screenshot of `:talk` web UI.

Let's delve into what we're looking at.

The `:talk` protocol is organized around _posts_ and _stations_.

A post is any type of message. It could be a a direct private message from a friend, you broadcasting a public message like a Tweet, or you receiving a news update through an API connector you've plugged into one of your station feeds.

A station is a feed of posts. Any ship can host or subscribe to any number of stations. Additionally, a station itself can be subscribed to other stations, which groups several feeds together in one place. One might want to do this to keep their "dev" station feed separate from their "social" and "music" station feeds

There are four kinds of stations: a publicly write-only `%mailbox` for only you to see, an invite-only `%village` for private group conversation, a publicly read-only `%journal` for curated content, and a public-access `%channel` for general use.

Every ship boots with a default main, private %mailbox station for direct messages and a personal first feed. This is called the 'court' station for galaxies, the 'floor' station for stars, and the 'porch' station for planets, moons and comets.

When a ship on Urbit subscribes to another `:talk` station, the default action right now is to subscribe that station to the ship's personal %mailbox station. Which, for most of us on either planets or comets, is our _porch_.

We'll go into these details more in a later section. But let's just try playing around with this in our current `:talk` web UI, and then see if we can replicate this functionality ourselves with the frontend tools already in your ship.

Since we're on comets, we can use this web UI to send ourselves a direct `:talk` message at our porch. A valid `:talk` _audience_, or the station we want to send our posts to, is just the string `~ship/station`.

In the web UI, the audience text box is just above the message text box. Let's send to our porch -- in my case, the audience `~darlen-natleb-modwer-falrud--bisrev-haltyd-ralwex-dolmyn/porch` -- the message, _'test from the talk web ui!'_

> zoom in screenshot on audience and text box

Hit your Enter key to send.

> GIF of typing, sending and receiving message in web UI and `:dojo`.

Messages sent through the `:talk` protocol on Urbit are encrypted, authenticated, typed, and exactly-once-delivered by default. And since this particular message was sent to your porch -- a publicly write-only, only personally readable station -- and since this `:talk` app doesn't rely on any central server other than your personal server to run, only you in fact are able to access, decrypt and read these particular messages.

> Note that, for now, we only allow `:talk` posts to be lowercase ASCII. For our `/urbit-meta` commons channel, this keeps things peaceful. But we're looking into ways for ships to be able to configure this on a per-channel basis.

Let's see if we if we can code our own simple way to send ourselves a private porch message by modifying our 'sayHi' code from the last section.

We know from the previous section that regular in-HTML `<script>` JavaScript works for trivial functions. For more complex functionality, of course, we'll want to separate our frontend code into its own directory and simply source the compiled ES5 from our HTML `<head>` like we did with urb.js.

For now, we'll stick with vanilla ES5 (we'll use React in Part 2 of this series). We've organized the `1.3` branch for you with a `tutorial` directory and new `main.js` inside, and your `tutorial.html` updated.

Let's `checkout` to it, then, and copy the code again into our ship's web directory:

```
$ git checkout -f 1.3
$ cp tutorial.html ~/mycomet/home/web && cp -r tutorial ~/mycomet/home/web
```

You should now have a `tutorial` directory in web, with a `main.js` file inside:

```
$ ls mycomet/home/web/tutorial
main.js
```

with `:dojo` recognizing the changed tutorial.html file and the added directory and main.js file:

```
: /~darlen-natleb-modwer-falrud--bisrev-haltyd-ralwex-dolmyn/home/5/web/tutorial/html
+ /~darlen-natleb-modwer-falrud--bisrev-haltyd-ralwex-dolmyn/home/5/web/tutorial/main/js
>
```

Let's load the page:

> 'Send yourself a `:talk` message, ~ship!' + textbox and submit

Go ahead, send yourself a message!

> GIF of sending message.

Let's look at the JSON payload we sent by checking our Network dev tool again:

```
{
  "oryx": "falwep-docder-marmev-norpur--sabsem-botlex-hodnup-dirsup",
  "xyro": {
    "publish": [
      {
        "serial": "0v7.985re.6urnn.8g80s.7mn5o.2njuo.0e4mk",
        "audience": {
          "~darlen-natleb-modwer-falrud--bisrev-haltyd-ralwex-dolmyn/porch": {
            "envelope": {
              "visible": true,
              "sender": null
            },
            "delivery": "pending"
          }
        },
        "statement": {
          "bouquet": [],
          "speech": {
            "lin": {
              "txt": "test from our own code!",
              "say": true
            }
          },
          "date": 1489430871493
        }
      }
    ]
  },
  "ship": "darlen-natleb-modwer-falrud--bisrev-haltyd-ralwex-dolmyn",
  "appl": "talk",
  "mark": "talk-command",
  "wire": "/"
}
```

It actually looks basically identical to the 'hi' payload from the last section, except for thisway different data payload. Which makes sense, after all. We're just sending a slightly different data payload to a different application, `talk`, using a different mark, `talk-command`, but using the same JSON payload format that `urb.send` and our ship's backend are expecting.

So, let's look under the hood of our code:

Your `tutorial.html` looks like this:

```
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Urbit from the Web</title>

    <script src="/~/at/=home=/web/lib/js/urb.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min.js"></script>
    <script src="/=home=/web/tutorial/main.js"></script>

</head>

<body>

    <div id="loadSend">
    </div>

    <script>
        var station = '';
        switch (window.urb.ship.length) {
            case 3:
                station = 'court';
                break;
            case 6:
                station = 'floor';
                break;
            default:
                station = 'porch';
                break;
        };

        var send = '';
        send += "<div class='send'>";
        send += '<h3>Send a `:talk` post to your ' + station + ', ~' + window.urb.ship + '!</h3>';
        send += '<br />';
        send += '<input type="text" id="audience" value="">'
        send += '<br />';
        send += '<input type="text" id="post" value="">'
        send += '<button onclick="sendPost();">Send!</button>';
        send += '</div>';
        document.getElementById('loadSend').innerHTML = send;
        document.getElementById('audience').value = '~' + window.urb.ship + '/' + station;

        function sendPost() {
            var post = document.getElementById('post').value;
            var audience = document.getElementById('audience').value;
            return send`:talk`Message(post, audience);
        }
    </script>

</body>

</html>
```

and here's your `main.js`:

```
function sendPost() {
    var post = document.getElementById('post').value;
    var audience = document.getElementById('audience').value;
    return send`:talk`Message(post, audience);
}

function uuid32() {
    var str = '0v';
    str += Math.ceil(Math.random() * 8) + '.';
    for (i = j = 0; j <= 5; i = ++j) {
        _str = Math.ceil(Math.random() * 10000000).toString(32);
        _str = ('00000' + _str).substr(-5, 5);
        str += _str + '.';
    }
    serial = str.slice(0, -1);
    return serial;
}

function send`:talk`Message(txt, audi) {
    var audience = {};
    audience[audi] = {
        envelope: {
            visible: true,
            sender: null
        },
        delivery: 'pending'
    };

    var speech = {
        lin: {
            txt: txt,
            say: true
        }
    };

    var message = {
        ship: window.urb.user,
        thought: {
            serial: uuid32(),
            audience: audience,
            statement: {
                bouquet: [],
                speech: speech,
                date: Date.now()
            }
        }
    };

    var obj = {};
    obj.publish = [message.thought];

    return window.urb.send(
        obj, {
            appl: 'talk',
            mark: 'talk-command'
        },
        function(err, res) {
            console.log('urb.send');
            console.log(obj);
            if (err || !res.data) {
                console.log(path, 'err!');
                console.log(err);
                return;
            }
            console.log(res.data);
            console.log('We just sent our ship a `:talk` message!');
        }
    );
}
```

The code actually isn't super interesting. The post needs a sender (your ship), an audience (your porch), a unique identifier (`uuid32()`), a date (`now`), and the post text itself.

But in short, we just sent another `urb.send` with a `:talk` payload instead to the `talk` app, which needs a `talk-command` mark.

All of the different urb.js requests are [here](http://urbit.org/docs/using/web/#-urb-js) in our Docs. Let's delve into a few more commands in the next sections though as it relates to using the `:talk` protocol for our own apps.

### 1.4 - Let's create a new station and send a post to it.

Having a single default station is great for just starting out with `:talk`. But it can quickly get out of control after subscribing to a number of stations that are highly active.

It'd be great if we could could separate our feeds a bit by having a second station separate from our porch. Let's see if we can do that.

With the same `1.3` code you have already loaded on the page, try simply changing your audience to a new station, something like, `~darlen-natleb-modwer-falrud--bisrev-haltyd-ralwex-dolmyn/a-second-station`, and sending yourself another `:talk` post:

> gif of trying to send self message, dojo error pops up.

Assuming you didn't change any code, your `:talk` command via your JSON payload must have been valid, as you were able to send a message to your porch last time. Thus, you shouldn't have gotten a callback error. But if you look in your `:dojo`, instead of printing your `:talk` post, you should have gotten a slightly cryptic error message:

```
[%ra-know-not ~.a-second-station]
~darlen_dolmyn:talk[]
```

Wat?

All your ship is telling you is, "Someone's trying to connect to a station of mine that I don't know anything about", because the stations doesn't exist. We haven't created it yet!

So, how do we create a station?

There's a `:talk` CLI command for creating stations. But it'd be cooler to do this exclusively through the browser.

We can effectively execute the same CLI function by sending a preceding JSON payload with a new `:talk` command that tells our ship to create the new station.

And it'd be great if, instead of manually having to create stations through a button or something before getting to send messages, we just automatically created the new station when we clicked the 'Send Post' button, executing this first `:talk` command before sending our message to then new station. All this takes is some extra JavaScript, where we'll just create the audience station before sending the message in case the station doesn't exist.

So this is what we'll do.

Checkout to branch `1.4`, and copy:

```
$ git checkout -f 1.4
$ cp tutorial.html ~/mycomet/home/web && cp -r tutorial ~/mycomet/home/web
```

Reload, and try sending to `a-second-station` again!

> gif of no response.

No response at all this time. What's up?

Turns out, it worked! You created the station and the post in fact went through. You're just not seeing the post in the second station because, well, it was sent to the second station! And by design, we wanted this station to be separate from your porch, which is the only feed your CLI `:talk` app is subscribed to.

Okay, so, how do we switch stations? Actually, we're still currently working on building this feature into both the `:talk` CLI and web app (this is still alpha software!). Right now, in our in-house apps, one station has been good enough for our MVP-like demo of both versions of the app, i.e. you can't easily organize your app feeds around a station other than your porch, and the stations your porch is subscribed to.

But this is actually what we're trying to highlight: that on Urbit, since you're in control of your data and the apps your run, and since this backend data is decoupled from the UI you view it from, you can _actually build_ this feature yourself by extending the frontend, or, in this case, writing a new frontend from scratch. As a developer-user, you're not constrained by the fact that us Tlon devs have been too busy to get around to this; you can have the apps and features you want.

Since we're starting from scratch, we can actually build this functionality ourselves in our own app just by sending a talk-command to send us a payload of all the posts of the station we want. Then, we can process this payload on our client side to load our second station's posts onto the page. A super vanilla version of this will only let us see one station at a time, but at least we'll learn a new `urb.js` request!

So let's do that. This will be our last section for Part 1.

### 1.5 - Let's finally load our station messages onto the page.

Checkout to branch `1.5` and copy the code in:

```
$ git checkout -f 1.5
$ cp tutorial.html ~/mycomet/home/web && cp -r tutorial ~/mycomet/home/web
```

Reload the page, and watch the magic happen!

> gif of messages of station loading automatically.

Again, the payload we received looks more complicated than it really is. All we got from your ship is a bundle of all the messages from our second station since yesterday (which, in this case, if just the few we sent in the last minute), and we displayed each of them sequentially on the page along with their author and date.

If your Network browser dev tool tab is still up, you should be noticing that you're still getting updates from your ship, like a kind of heartbeat. In fact, this is what `urb.bind` does, the urb.js request type we used for this last section. We're specifying by the path, or `wire`, of our request, that we want all the messages of this station since yesterday. And since our request `PUT` an `urb.bind` request at this path, we essentially told our ship to send us continuous updates about every 30 seconds, like push notifications for iOS.

But wait, 30 seconds seems like kind of a long time for synchronous messaging. If I'm DMing a friend, I totally want to get their messages as soon as they arrive to my ship's backend.

Actually, the 30 second heartbeat is just to reload the feed in case our frontend messed something. Really, your ship does send you new payloads immediately upon arrival, and the page page should refresh automatically.

Let's test this by sending ourself one last message to our second station from the `:dojo`.

> gif of sending message from `:dojo`, messages disappearing except last.

Welp, I guess this is as far as vanilla JavaScript gets us. We'll need a more sophisticated state management system like React/Redux if we want a truly awesome `:talk` app.

But hopefully this tutorial helped you understand some of the basic frontend functionality of Urbit, and how Urbit web apps can work generally.

Thanks for reading!
